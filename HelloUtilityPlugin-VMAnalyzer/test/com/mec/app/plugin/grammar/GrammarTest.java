package com.mec.app.plugin.grammar;

import java.io.PrintStream;
import java.util.Optional;

import org.junit.Ignore;
import org.junit.Test;

import com.mec.app.plugin.grammar.Grammar.ParseResult;
import com.mec.app.plugin.grammar.Grammar1.Expr;
import com.mec.app.plugin.grammar.Grammar4.Token;

public class GrammarTest {

	@Ignore
	@Test
	public void test() {
//		fail("Not yet implemented");
		
		
		String str = "9+5-2";
		
		Grammar g1 = new Grammar1();
		
//		Grammar g2 = new Grammar2();
		
		ParseResult<Expr> result1 = g1.parse(str);
//		g2.parse(str);
		
		//expected: 95+2-
		out.printf("%s -> %s\n", str, result1.getResult());
		
		str = "9-5+2";
		ParseResult<Expr> result2 = g1.parse(str);
		out.printf("%s -> %s\n", str, result2.getResult());
		
		
		str = "1+2-3+4-5+6-7+8-9";
		out.printf("%s -> %s\n", str, g1.parse(str).getResult());
	}
	
	@Ignore
	@Test
	public void testInvalidExpression(){
		Grammar g1 = new Grammar1();
		String str = "1+2-3+";
		try{
			out.printf("%s -> %s\n", str, g1.parse(str).getResult());
		}catch(Exception e){
//			out.printf("%s - %s\n", e.getClass().getName(), e.getMessage());
		}
		
		out.println();
		str = "1+2-+";
		try{
			out.printf("%s -> %s\n", str, g1.parse(str).getResult());
		}catch(Exception e){
//			out.printf("%s - %s\n", e.getClass().getName(), e.getMessage());
		}
		
		out.println();
		str = "+2-+";
		try{
			out.printf("%s -> %s\n", str, g1.parse(str).getResult());
		}catch(Exception e){
//			out.printf("%s - %s\n", e.getClass().getName(), e.getMessage());
		}
		
		out.println();
		str = "2+34-5";
		try{
			out.printf("%s -> %s\n", str, g1.parse(str).getResult());
		}catch(Exception e){
//			out.printf("%s - %s\n", e.getClass().getName(), e.getMessage());
		}
		
		out.println();
		str = "1+2-3*4/5";
		try{
			out.printf("%s -> %s\n", str, g1.parse(str).getResult());
		}catch(Exception e){
			out.printf("%s - %s\n", e.getClass().getName(), e.getMessage());
		}
	}
	
	@Ignore
	@Test
	public void testExecuteExpression(){
		String str = "9-5+2";
		
		Grammar g1 = new Grammar1();
		
		ParseResult<Expr> result1 = g1.parse(str);
		
		GrammarExecutor<Expr, Integer> exec = new Grammar1Executor();
		out.printf("%s evaluate result: %s\n", str, exec.execute(result1));
	}


	@Ignore
	@Test
	public void testGrammar2PredictiveParsing(){
//		String stmtStr = "for(; expr; expr) other";	//<- space is not supported for now
		String stmtStr = "for(;expr;expr)other";
		Grammar g2 = new Grammar2PredictiveParsing();
		g2.parse(stmtStr);
	}
	
	@Ignore
	@Test
	public void testGrammar3(){
		String stmtStr = "1+2-3+4-5+6";
		Grammar g3 = new Grammar3();
		g3.parse(stmtStr);
	}
	
	@Ignore
	@Test
	public void testGrammar2Lexer(){
		String str = "1+2-3*4/5";
		printTokens(str);
		
		printTokens("1   +2   4 /5 * 6789 ");
		printTokens("1   +2   4 /5 ^ 67 # @ ()89 ");
		printTokens("1   +2 Wahat der111 zzx .  4 /5 ^ 67 # @ ()89 ");
	}
	
	private void printTokens(String str){
		Grammar4.Lexer lexer = new Grammar4.Lexer(str);
		for(Optional<Token> token = lexer.nextToken();
				token.isPresent();
				token = lexer.nextToken()){
			out.printf(" %s ", token.get());
		}
		out.println();
	}
//	/**
//	 * Example 2.10:  The annotated parse tree listed below is based on the translation
//	 * expressions consisting of digits separated by plus or minus signs into postfix notation. 
//	 * Each nonterminal has a string-valued attribute t that represents the postfix notation
//	 * for the expression generated by that nonterminal in a parse tree. The symbol || in 
//	 * the semantic rule is the operator for string concatenation
//	 * 
//	 * Product						Semantic Rules
//	 * expr -> expr_1 + term		expr.t = expr_1.t || term.t || '+'
//	 * expr -> expr_1 - term		expr.t = expr_1.t || term.t || '-'
//	 * expr -> term					expr.t = term.t
//	 * term -> 0					term.0 = '0'
//	 * term -> 1					term.1 = '1'
//	 * ...
//	 * term -> 9					term.t = '9'
//	 * 
//	 * Another production rule for expr:
//	 * expr -> term + right
//	 * expr -> term - right
//	 * right -> term + right
//	 * right -> term - right
//	 * right -> {empty}
//	 * term -> 0 | 1 | 2 | ... | 9
//	 * 
//	 * @author MEC
//	 *
//	 */
//	static class Grammar1 implements Grammar{
//		@Override
//		public ParseResult parse(String str){
////			final char NON_CHAR = '0x00';
//			Objects.requireNonNull(str);
////			char[] chars = str.toCharArray();
////			Scanner scanner = new Scanner(str);	//<- The Tokenizer || Lexical Recognizer should be implemented by hand as well;
//			
////			char prev = NON_CHAR;
////			for(int i = 0; i < chars.length; ++i){
////				char cur = chars[i];
////				
////			}
//			
//			Scanner scanner = new Scanner(str);
//			
//			//Get expr_right
////			Term term = Term.of(scanner.nextInt());
////			while(scanner.hasNext()){
////				OpType op = OpType.of(scanner.nextChar());
//////				Expr rightExpr getExpr(scanner);
////			}
//			getExpr(scanner);
//			
//			
//			return null;
//		}
//		
//		
//		private Expr getExpr(Scanner scanner){
//			Term term = Term.of(scanner.nextInt());
//			Expr retval = Expr.of(term);
//			if(scanner.hasNext()){
//				OpType op = OpType.of(scanner.nextChar());
//				Expr expr = getExpr(scanner);
//				retval.setOp(op);
//				retval.setExpr(expr);
//			}
//			return retval;
//		}
//		
//		
//		static class Scanner{
//			Scanner(String str){
//				Objects.requireNonNull(str);
//				chars = str.toCharArray();
//			}
//	
//			public int nextInt(){
//				char digitChar = chars[curIndex++];
//				if(!Character.isDigit(digitChar)){
//					throw new IllegalArgumentException(String.format("%s is not digit char", digitChar));
//				}
//				
//				return Integer.parseInt(Character.toString(digitChar));
//			}
//			
//			public char nextChar(){
//				return chars[curIndex++];
//			}
//			
//			public boolean hasNext(){
//				return curIndex < chars.length;
//			}
//			private char chars[];
//			private int curIndex = 0;
//			
//		}
//	
//		static class Expr{
//			
//			private Expr(Expr left, OpType op, Term right){
//				this.expr = left;
//				this.op = op;
//				this.right = right;
//			}
//			
//			public static Expr of(Term term){
//				return new Expr(null, null, term);
//			}
//			
//			public static Expr of(Expr left, OpType op, Term right){
//				return new Expr(left, op, right);
//			}
//			
//			public void setOp(OpType op){
//				this.op = op;
//			}
//			public void setExpr(Expr expr){
//				this.expr = expr;
//			}
//			public String getValue(){
//				return String.format(
//						"%s%s%s"
//						, Optional.ofNullable(expr).map(Expr::getValue).orElse("")
//						, right.getValue()
//						, op.getValue()
//						);
//			}
//			
//			private Expr expr;
//			private OpType op;
//			private Term right;
//		}
//		
//		static class Term{
//			private Term(int value){
//				t = value;
//			}
//			
//			public static Term of(int value){
//				return new Term(value);
//			}
//			
//			public String getValue(){
//				return String.valueOf(t);
//			}
//			
//			int t;	//attribute;
//		}
//		
//		enum OpType{
//			ADD('+')
//			,SUBSTRACT('-')
//			;
//			
//			private OpType(char value){
//				val = value;
//			}
//			
//			public char getValue(){
//				return val;
//			}
//			
//			public static OpType of(char value){
//				return valMap.get(value);
//			}
//			
//			private static Map<Character, OpType> valMap = new HashMap<>();;
//			private char val;
//			static{
//				Arrays.stream(OpType.values()).forEach(op -> valMap.put(op.getValue(), op));
//			}
//		}
////		char lookahread;
//	}
	
//	static class Grammar2 implements Grammar{
//		
//		@Override
//		public ParseResult parse(String str){
//			return null;
//		}
//	}
	
//	enum Terminals{
//		T0(0)
//		,T1(1)
//		,T2(2)
//		,T3(3)
//		,T4(4)
//		,T5(5)
//		,T6(6)
//		,T7(7)
//		,T8(8)
//		,T9(9)
//		;
//		
//		
//		
//		private Terminals(int val){
//			this.value = val;
//		}
//		
//		public int getValue(){
//			return value;
//		}
//		
//		private int value;
//	}
	
	private static final PrintStream out = System.out;
}
