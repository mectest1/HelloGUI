package com.mec.app.plugin.grammar;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

/**
 * Example 2.10:  The annotated parse tree listed below is based on the translation
 * expressions consisting of digits separated by plus or minus signs into postfix notation. 
 * Each nonterminal has a string-valued attribute t that represents the postfix notation
 * for the expression generated by that nonterminal in a parse tree. The symbol || in 
 * the semantic rule is the operator for string concatenation
 * 
 * Product						Semantic Rules
 * expr -> expr_1 + term		expr.t = expr_1.t || term.t || '+'
 * expr -> expr_1 - term		expr.t = expr_1.t || term.t || '-'
 * expr -> term					expr.t = term.t
 * term -> 0					term.0 = '0'
 * term -> 1					term.1 = '1'
 * ...
 * term -> 9					term.t = '9'
 * 
 * Another production rule for expr:
 * expr -> term + expr_right
 * expr -> term - expr_right
 * expr_right -> term + expr_right
 * expr_right -> term - expr_right
 * expr_right -> {empty}
 * term -> 0 | 1 | 2 | ... | 9
 * 
 * @author MEC
 *
 */
public class Grammar1 implements Grammar{
	@Override
	public ParseResult<Expr> parse(String str){
//		final char NON_CHAR = '0x00';
		Objects.requireNonNull(str);
//		char[] chars = str.toCharArray();
//		Scanner scanner = new Scanner(str);	//<- The Tokenizer || Lexical Recognizer should be implemented by hand as well;
		
//		char prev = NON_CHAR;
//		for(int i = 0; i < chars.length; ++i){
//			char cur = chars[i];
//			
//		}
		
		Scanner scanner = new Scanner(str);
		
		//Get expr_right
//		Term term = Term.of(scanner.nextInt());
//		while(scanner.hasNext()){
//			OpType op = OpType.of(scanner.nextChar());
////			Expr rightExpr getExpr(scanner);
//		}
		Expr expr = getExpr(scanner);
		
		
		return ParseResult.of(expr);
	}
	
	
	private Expr getExpr(Scanner scanner){
		Term term = Term.of(scanner.nextInt());
		Expr retval = Expr.of(term);
		if(scanner.hasNext()){
			OpType op = OpType.of(scanner.nextChar());
			Expr expr = getExpr(scanner);
			retval.setOp(op);
			retval.setExpr(expr);
		}
		return retval;
	}
	
	
	static class Scanner{
		Scanner(String str){
			Objects.requireNonNull(str);
			chars = str.toCharArray();
		}

		public int nextInt(){
			char digitChar = chars[curIndex++];
			if(!Character.isDigit(digitChar)){
				throw new IllegalArgumentException(String.format("%s is not digit char", digitChar));
			}
			
			return Integer.parseInt(Character.toString(digitChar));
		}
		
		public char nextChar(){
			return chars[curIndex++];
		}
		
		public boolean hasNext(){
			return curIndex < chars.length;
		}
		private char chars[];
		private int curIndex = 0;
		
	}

	static class Expr{
		
		private Expr(Expr expr, OpType op, Term term){
			this.exprRight = expr;
			this.op = op;
			this.term = term;
		}
		
		public static Expr of(Term term){
			return new Expr(null, null, term);
		}
		
		public static Expr of(Expr expr, OpType op, Term term){
			return new Expr(expr, op, term);
		}
		
		public void setOp(OpType op){
			this.op = op;
		}
		public void setExpr(Expr expr){
			this.exprRight = expr;
		}
		public String getValue(){
//			char derp = "".;
//			return String.format(
//					"%s%s%s"
//					, term.getValue()
//					, Optional.ofNullable(exprRight).map(Expr::getValue).orElse(EMPTY_STR)
//					, Optional.ofNullable(
//							Optional.ofNullable(op).map(opType -> String.valueOf(opType.getValue()))
//						).map(p -> p.orElse(EMPTY_STR)).get()
//					);
			StringBuilder retval = new StringBuilder();
			if(null != exprRight){
				retval.append(exprRight.getValue()).append(term.toString()).append(op.getValue());
			}else{
				retval.append(term.getValue());
			}
			return retval.toString();
		}
		
		@Override
		public String toString(){
			return getValue();
		}
		private Expr exprRight;
		private OpType op;
		private Term term;
		private static final String EMPTY_STR = "";
	}
	
	static class Term{
		private Term(int value){
			t = value;
		}
		
		public static Term of(int value){
			return new Term(value);
		}
		
		public String getValue(){
			return String.valueOf(t);
		}
		
		@Override
		public String toString(){
			return getValue();
		}
		
		int t;	//attribute;
	}
	
	enum OpType{
		ADD('+')
		,SUBSTRACT('-')
		;
		
		private OpType(char value){
			val = value;
		}
		
		public char getValue(){
			return val;
		}
		
		public static OpType of(char value){
			return valMap.get(value);
		}
		
		@Override
		public String toString(){
			return Character.toString(getValue());
		}
		
		private static Map<Character, OpType> valMap = new HashMap<>();;
		private char val;
		static{
			Arrays.stream(OpType.values()).forEach(op -> valMap.put(op.getValue(), op));
		}
	}
//	char lookahread;
}
