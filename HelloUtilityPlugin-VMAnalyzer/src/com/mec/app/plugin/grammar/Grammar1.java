package com.mec.app.plugin.grammar;

import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.ToIntBiFunction;
import java.util.stream.Stream;

/**
 * Example 2.10:  The annotated parse tree listed below is based on the translation
 * expressions consisting of digits separated by plus or minus signs into postfix notation. 
 * Each nonterminal has a string-valued attribute t that represents the postfix notation
 * for the expression generated by that nonterminal in a parse tree. The symbol || in 
 * the semantic rule is the operator for string concatenation
 * 
 * Product						Semantic Rules
 * expr -> expr_1 + term		expr.t = expr_1.t || term.t || '+'
 * expr -> expr_1 - term		expr.t = expr_1.t || term.t || '-'
 * expr -> term					expr.t = term.t
 * term -> 0					term.0 = '0'
 * term -> 1					term.1 = '1'
 * ...
 * term -> 9					term.t = '9'
 * 
 * @author MEC
 *
 */
public class Grammar1 implements Grammar{
//	@SuppressWarnings("unchecked")
	@Override
	public ParseResult<Expr> parse(String str){
		Objects.requireNonNull(str);
		
		Scanner scanner = new Scanner(str);
		
		Expr expr = new Expr(Expr.of(scanner.nextTerm()));
		while(scanner.hasNext()){
			expr = new Expr(expr);
			expr.setOp(scanner.nextOp());
			expr.setTerm(scanner.nextTerm());
		}
		
		return ParseResult.of(expr);
	}
	
	static class Scanner{
		Scanner(String str){
			Objects.requireNonNull(str);
			chars = str.toCharArray();
		}

		private int nextInt(){
			char digitChar = chars[curIndex++];
			if(!Character.isDigit(digitChar)){
				throw new IllegalArgumentException(String.format("%s is not digit char", digitChar));
			}
			
			return Integer.parseInt(Character.toString(digitChar));
		}
		
		private char nextChar(){
			return chars[curIndex++];
		}
		
		public boolean hasNext(){
			return curIndex < chars.length;
		}
		
		public Term nextTerm(){
			try{
				return Term.of(nextInt());
			}catch(ArrayIndexOutOfBoundsException | IllegalArgumentException e){
				out.printf("Error: digit character expected at index %s\n", curIndex);
				printPositionInfo();
				throw e;
			}
		}
		
		public OpType nextOp(){
			try{
				char ch = nextChar();
				OpType retval =  OpType.of(ch);
				if(null == retval){
					throw new IllegalArgumentException(String.format("Unrecognized operator: %s", ch));
				}
				return retval;
			}catch(ArrayIndexOutOfBoundsException | IllegalArgumentException e){
				out.printf("Error: operator character expected at index %s\n", curIndex);
				printPositionInfo();
				throw e;
			}
		}
		
		
		private boolean hasNextOp(){
			return hasNext() && null != OpType.of(chars[curIndex + 1]);
		}
		
		private boolean hasNextTerm(){
			return hasNext() && Term.isValidTerm(chars[curIndex + 1]);
		}
		
		private void printPositionInfo(){
			out.println(String.valueOf(chars));
//			Stream.of(chars).forEach(c -> out.print(" "));
//			for(int i = 0; i < chars.length; ++i) out.print(" ");
			for(int i = 0; i < curIndex - 1; ++i) out.print(" ");
			out.println("^");
		}
		
		
		private char chars[];
		private int curIndex = 0;
		private static final PrintStream out = System.out;
//		private static final PrintStream err = System.err;
	}

	static class Expr{
		
		protected Expr(){
			
		}
		
		protected Expr(Expr expr){
			this.expr = expr;
		}
		private Expr(Expr expr, OpType op, Term term){
			this.expr = expr;
			this.op = op;
			this.term = term;
		}
		
		public static Expr of(Term term){
			return new Expr(null, null, term);
		}

		public void setOp(OpType op){
			this.op = op;
		}
		public void setExpr(Expr expr){
			this.expr = expr;
		}
		public void setTerm(Term term){
			this.term = term;
		}
	
		public String getValue(){
			//Two complicated for good
//			return String.format(
//					"%s%s%s"
//					, Optional.ofNullable(exprRight).map(Expr::getValue).orElse(EMPTY_STR)
//					, term.getValue()
//					, Optional.ofNullable(
//							Optional.ofNullable(op).map(opType -> String.valueOf(opType.getValue()))
//						).map(p -> p.orElse(EMPTY_STR)).get()
//					);
			StringBuilder retval = new StringBuilder();
			if(null != expr){
				retval.append(expr.getValue());
				if(null != op){
					retval.append(term.toString()).append(op.getValue());
				}
			}else{
				retval.append(term.getValue());
			}
			return retval.toString();
		}
		
		@Override
		public String toString(){
			return getValue();
		}
		
		public int evaluate(){
			int retval = 0;
			if(null == op){
				if(null != term){
					retval = term.getValue();
				}else{
					retval = expr.evaluate();
				}
			}else{
				retval = op.calculate(expr.evaluate(), term.getValue());
			}
			
			return retval;
		}

		private Expr expr;
		private OpType op;
		private Term term;
//		private static final String EMPTY_STR = "";
	}
	
	static class Term{
		private Term(int value){
			t = value;
		}
		
		public static Term of(int value){
			return new Term(value);
		}
		
		public int getValue(){
			return t;
		}
		
		public static final boolean isValidTerm(char ch){
			return Character.isDigit(ch);
		}
		@Override
		public String toString(){
			return String.valueOf(getValue());
		}
		
		int t;	//attribute;
	}
	
	enum OpType{
		ADD('+', (l, r) -> l + r)
		,SUBSTRACT('-', (l, r) -> l - r)
		;
		
		private OpType(char value, ToIntBiFunction<Integer, Integer> calRule){
			val = value;
			this.calculateRule = calRule;
		}
		
		public char getValue(){
			return val;
		}
		
		public int calculate(int left, int right){
			return calculateRule.applyAsInt(left, right);
		}
	
		public static OpType of(char value){
			return valMap.get(value);
		}
		
		
		@Override
		public String toString(){
			return Character.toString(getValue());
		}
		
		private static Map<Character, OpType> valMap = new HashMap<>();;
		private char val;
		private ToIntBiFunction<Integer, Integer> calculateRule;
		static{
			Arrays.stream(OpType.values()).forEach(op -> valMap.put(op.getValue(), op));
		}
	}
}
